<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebGL</title>
    <style>
      canvas {
        background: pink;
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js" crossorigin="anonymous"></script>
  </head>
  <body>
    <canvas width="300" height="300"></canvas>
    <script>
      var cubeRotation = 0.0
      {
        let canvas = document.querySelector("canvas")
        let gl = canvas.getContext("webgl")

        const vsSource = `
        attribute vec4 aVertexPosition;
        attribute vec2 aTextureCoord;

        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;

        varying highp vec2 vTextureCoord;


        void main() {
          gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
          vTextureCoord = aTextureCoord;
        }
      `
        const fsSource = `
        varying highp vec2 vTextureCoord;
        uniform sampler2D uSampler;

        void main() {
          gl_FragColor = texture2D(uSampler, vTextureCoord);
        }
      `

        const shaderProgram = initShaderProgram(gl, vsSource, fsSource)

        const programInfo = {
          program: shaderProgram,
          attribLocations: {
            vertexPosition: gl.getAttribLocation(shaderProgram, "aVertexPosition"),
            textureCoord: gl.getAttribLocation(shaderProgram, "aTextureCoord"),
          },
          uniformLocations: {
            projectionMatrix: gl.getUniformLocation(shaderProgram, "uProjectionMatrix"),
            modelViewMatrix: gl.getUniformLocation(shaderProgram, "uModelViewMatrix"),
            uSampler: gl.getUniformLocation(shaderProgram, "uSampler"),
          },
        }

        const buffers = initBuffers(gl)

        let then = 0
        function render(now) {
          now *= 0.001
          const deltaTime = now - then
          then = now

          drawScene(gl, programInfo, buffers, texture, deltaTime)

          requestAnimationFrame(render)
        }

        requestAnimationFrame(render)
      }

      function initBuffers(gl) {
        const positionBuffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)
        const positions = [
          // Front face
          -1.0,
          -1.0,
          1.0,
          1.0,
          -1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          -1.0,
          1.0,
          1.0,

          // Back face
          -1.0,
          -1.0,
          -1.0,
          -1.0,
          1.0,
          -1.0,
          1.0,
          1.0,
          -1.0,
          1.0,
          -1.0,
          -1.0,

          // Top face
          -1.0,
          1.0,
          -1.0,
          -1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          -1.0,

          // Bottom face
          -1.0,
          -1.0,
          -1.0,
          1.0,
          -1.0,
          -1.0,
          1.0,
          -1.0,
          1.0,
          -1.0,
          -1.0,
          1.0,

          // Right face
          1.0,
          -1.0,
          -1.0,
          1.0,
          1.0,
          -1.0,
          1.0,
          1.0,
          1.0,
          1.0,
          -1.0,
          1.0,

          // Left face
          -1.0,
          -1.0,
          -1.0,
          -1.0,
          -1.0,
          1.0,
          -1.0,
          1.0,
          1.0,
          -1.0,
          1.0,
          -1.0,
        ]

        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW)

        const textureCoordinates = [
          // Front
          0.0,
          0.0,
          1.0,
          0.0,
          1.0,
          1.0,
          0.0,
          1.0,
          // Back
          0.0,
          0.0,
          1.0,
          0.0,
          1.0,
          1.0,
          0.0,
          1.0,
          // Top
          0.0,
          0.0,
          1.0,
          0.0,
          1.0,
          1.0,
          0.0,
          1.0,
          // Bottom
          0.0,
          0.0,
          1.0,
          0.0,
          1.0,
          1.0,
          0.0,
          1.0,
          // Right
          0.0,
          0.0,
          1.0,
          0.0,
          1.0,
          1.0,
          0.0,
          1.0,
          // Left
          0.0,
          0.0,
          1.0,
          0.0,
          1.0,
          1.0,
          0.0,
          1.0,
        ]

        const textureCoordBuffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer)
        gl.bufferData(gl.ARRAY_BUFFER, textureCoordinates)

        const indexBuffer = gl.createBuffer()
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

        const indices = [
          0,
          1,
          2,
          0,
          2,
          3, // front
          4,
          5,
          6,
          4,
          6,
          7, // back
          8,
          9,
          10,
          8,
          10,
          11, // top
          12,
          13,
          14,
          12,
          14,
          15, // bottom
          16,
          17,
          18,
          16,
          18,
          19, // right
          20,
          21,
          22,
          20,
          22,
          23, // left
        ]
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW)

        return {
          position: positionBuffer,
          textureCoord: textureCoordBuffer,
          indices: indexBuffer,
        }
      }

      function loadTexture(gl, url) {
        const texture = gl.createTexture()
        gl.bindTexture(gl.TEXTURE_2D, texture)
        const level = 0
        const internalFormat = gl.RGBA
        const width = 1
        const height = 1
        const border = 0
        const srcFormat = gl.RGBA
        const srcType = gl.UNSIGNED_BYTE
        const pixel = new Uint8Array([0, 0, 255, 255])

        gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, srcFormat, srcType, pixel)

        const image = new Image()
        img.onload = function () {
          gl.bindTexture(gl.TEXTURE_2D, texture)
          gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, image)

          if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
            // Yes, it's a power of 2. Generate mips.
            gl.generateMipmap(gl.TEXTURE_2D)
          } else {
            // No, it's not a power of 2. Turn of mips and set
            // wrapping to clamp to edge
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
          }

          image.src = url

          return texture
        }
      }

      function isPowerOf2(value) {
        return (value & (value - 1)) == 0
      }

      function drawScene(gl, programInfo, buffers, deltaTime) {
        gl.clearColor(0.0, 0.0, 0.0, 1.0)
        gl.clearDepth(1.0)
        gl.enable(gl.DEPTH_TEST)
        gl.depthFunc(gl.LEQUAL)

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

        const fieldOfView = (45 * Math.PI) / 180
        const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight
        const zNear = 0.1
        const zFar = 100.0
        const projectionMatrix = mat4.create()

        mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar)

        const modelViewMatrix = mat4.create()

        mat4.translate(modelViewMatrix, modelViewMatrix, [-0.0, 0.0, -6.0])
        mat4.rotate(modelViewMatrix, modelViewMatrix, cubeRotation, [0, 0, 1])
        mat4.rotate(modelViewMatrix, modelViewMatrix, cubeRotation * 0.7, [0, 1, 0])

        {
          const numComponents = 3
          const type = gl.FLOAT
          const normalize = false
          const stride = 0
          const offset = 0
          gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position)
          gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, numComponents, type, normalize, stride, offset)
          gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition)
        }

        {
          const numComponents = 4
          const type = gl.FLOAT
          const normalize = false
          const stride = 0
          const offset = 0
          gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color)
          gl.vertexAttribPointer(programInfo.attribLocations.vertexColor, numComponents, type, normalize, stride, offset)
          gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor)
        }

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices)

        gl.useProgram(programInfo.program)

        gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix)

        gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix)

        {
          const vertexCount = 36
          const type = gl.UNSIGNED_SHORT
          const offset = 0
          gl.drawElements(gl.TRIANGLES, vertexCount, type, offset)
        }

        cubeRotation += deltaTime
      }

      function initShaderProgram(gl, vsSource, fsSource) {
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource)
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource)

        const shaderProgram = gl.createProgram()
        gl.attachShader(shaderProgram, vertexShader)
        gl.attachShader(shaderProgram, fragmentShader)
        gl.linkProgram(shaderProgram)

        return shaderProgram
      }

      function loadShader(gl, type, source) {
        const shader = gl.createShader(type)

        gl.shaderSource(shader, source)

        gl.compileShader(shader)

        return shader
      }
    </script>
  </body>
</html>
